# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for dynamic methods in `Formula`.
# Please instead update this file by running `bin/tapioca dsl Formula`.


class Formula
  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def allow_network_access!(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def bottle_defined?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def bottle_specification(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def bottle_tag?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def bottled?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def cached_download(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def clear_cache(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def compiler_failures(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def declared_deps(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deny_network_access!(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def deprecated?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecated_flags(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecated_options(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_date(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_reason(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deprecation_replacement(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def deps(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def desc(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_date(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_reason(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def disable_replacement(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def disabled?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def downloader(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def env(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def homepage(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def keg_only_reason(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def license(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def livecheck(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def livecheck_defined?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def livecheckable?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def loaded_from_api?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def network_access_allowed?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def option_defined?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def options(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def patchlist(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def pin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def pinnable?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def pinned?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def pinned_version(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def pour_bottle_check_unsatisfied_reason(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def requirements(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def resources(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T::Boolean) }
  def service?(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def unpin(*args, &block); end

  sig { params(args: T.untyped, block: T.untyped).returns(T.untyped) }
  def version(*args, &block); end

  class << self
    sig { params(arg: T.untyped).returns(T.untyped) }
    def desc(arg = nil); end

    sig { params(arg: T.untyped).returns(T.untyped) }
    def homepage(arg = nil); end

    sig { returns(T::Boolean) }
    def loaded_from_api?; end

    sig { returns(T::Boolean) }
    def on_system_blocks_exist?; end

    sig { params(arg: T.untyped).returns(T.untyped) }
    def revision(arg = nil); end

    sig { params(arg: T.untyped).returns(T.untyped) }
    def version_scheme(arg = nil); end
  end
end
